name: Shipwright Pipeline

# Include issue number in run title so auto-retry and watchdog can find it
run-name: "Shipwright Pipeline #${{ github.event.inputs.issue_number || github.event.issue.number || '?' }}"

# Autonomous agents process labeled issues ‚Äî Shipwright building itself
on:
  issues:
    types: [labeled]
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Issue number to process"
        required: true
        type: number
      template:
        description: "Pipeline template (fast, standard, full, autonomous)"
        required: false
        default: "autonomous"
        type: choice
        options:
          - fast
          - standard
          - full
          - autonomous
          - cost-aware
      skip_triage:
        description: "Skip issue triage (maintainer override)"
        required: false
        default: false
        type: boolean
      max_iterations:
        description: "Max build loop iterations (0 = auto from triage)"
        required: false
        default: "0"
        type: string
      completed_stages:
        description: "Comma-separated stages to skip (for CI resume)"
        required: false
        default: ""
        type: string

# Only one pipeline per issue at a time
concurrency:
  group: shipwright-issue-${{ github.event.inputs.issue_number || github.event.issue.number }}
  cancel-in-progress: false

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  # Stage 1: Triage ‚Äî vet the issue and determine delivery strategy
  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  triage:
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event.action == 'labeled' && github.event.label.name == 'shipwright')
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      approved: ${{ steps.skip.outputs.approved || steps.triage.outputs.approved }}
      reason: ${{ steps.skip.outputs.reason || steps.triage.outputs.reason }}
      complexity: ${{ steps.skip.outputs.complexity || steps.triage.outputs.complexity }}
      template: ${{ steps.skip.outputs.template || steps.strategy.outputs.template }}
      max_iterations: ${{ steps.skip.outputs.max_iterations || steps.strategy.outputs.max_iterations }}
      estimated_minutes: ${{ steps.skip.outputs.estimated_minutes || steps.strategy.outputs.estimated_minutes }}
      risk_level: ${{ steps.risk.outputs.risk_level }}
      risk_score: ${{ steps.risk.outputs.risk_score }}

    env:
      ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number }}
      CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    steps:
      - uses: actions/checkout@v4

      - name: Rate limit jitter
        run: |
          # Stagger API calls when multiple issues are labeled simultaneously
          # to avoid GitHub GraphQL rate limit stampede (5-50s random delay)
          JITTER=$((RANDOM % 45 + 5))
          echo "Sleeping ${JITTER}s to avoid rate limit stampede..."
          sleep "$JITTER"

      - name: Skip triage (maintainer override)
        if: github.event.inputs.skip_triage == 'true'
        id: skip
        run: |
          echo "approved=true" >> "$GITHUB_OUTPUT"
          echo "reason=Maintainer override ‚Äî triage skipped" >> "$GITHUB_OUTPUT"
          echo "complexity=standard" >> "$GITHUB_OUTPUT"
          echo "template=autonomous" >> "$GITHUB_OUTPUT"
          echo "max_iterations=20" >> "$GITHUB_OUTPUT"
          echo "estimated_minutes=90" >> "$GITHUB_OUTPUT"

      - name: Fetch issue details
        if: steps.skip.conclusion == 'skipped'
        id: issue
        run: |
          ISSUE_JSON=$(gh issue view "$ISSUE_NUMBER" --json title,body,labels,author)
          TITLE=$(echo "$ISSUE_JSON" | jq -r '.title')
          BODY=$(echo "$ISSUE_JSON" | jq -r '.body // ""' | head -200)
          LABELS=$(echo "$ISSUE_JSON" | jq -r '[.labels[].name] | join(", ")')
          AUTHOR=$(echo "$ISSUE_JSON" | jq -r '.author.login')

          echo "title=$TITLE" >> "$GITHUB_OUTPUT"
          echo "author=$AUTHOR" >> "$GITHUB_OUTPUT"
          echo "labels=$LABELS" >> "$GITHUB_OUTPUT"

          # Save body to file (too long for env var)
          echo "$BODY" > /tmp/issue-body.txt

      - name: Vet issue alignment and determine strategy
        if: steps.skip.conclusion == 'skipped'
        id: triage
        run: |
          TITLE="${{ steps.issue.outputs.title }}"
          LABELS="${{ steps.issue.outputs.labels }}"
          AUTHOR="${{ steps.issue.outputs.author }}"
          BODY=$(cat /tmp/issue-body.txt 2>/dev/null || echo "")

          # Build triage prompt with strategy engine
          cat > /tmp/triage-prompt.txt <<'TRIAGE_EOF'
          You are the triage gate for the Shipwright open-source project.

          ## Shipwright Mission
          Shipwright orchestrates autonomous Claude Code agent teams. It provides:
          - Delivery pipelines (issue -> plan -> build -> test -> review -> PR)
          - Daemon-driven issue processing with auto-scaling
          - Fleet management across multiple repos
          - Agent heartbeats, checkpoints, and fault tolerance
          - Multi-machine distributed workers
          - Real-time web dashboard with agent presence
          - Cost intelligence and budget enforcement
          - Persistent memory and failure pattern learning
          - tmux-based team sessions with templates

          ## Alignment Criteria
          An issue ALIGNS if it:
          1. Improves Shipwright's core functionality (pipelines, daemons, fleet, dashboard)
          2. Fixes bugs or improves reliability/resilience
          3. Improves developer experience (CLI, docs, templates, setup)
          4. Adds cross-platform support (Linux, macOS, WSL)
          5. Improves test coverage or CI/CD
          6. Enhances cost efficiency, metrics, or observability
          7. Improves security or error handling

          An issue DOES NOT ALIGN if it:
          1. Requests features unrelated to agent orchestration
          2. Is spam, low-effort, or unclear
          3. Requests integration with unrelated tools (unless clearly valuable)
          4. Would introduce unnecessary complexity or scope creep
          5. Duplicates existing functionality
          6. Is a support question (should be a Discussion, not Issue)

          ## Complexity and Strategy
          Evaluate the issue and recommend a delivery strategy:
          - fast: trivial fix, typo, config change (< 30 min, ~5 iterations)
          - standard: feature or bugfix touching 2-5 files (< 2 hours, ~15 iterations)
          - full: significant feature or refactor (> 2 hours, multiple subsystems, ~25 iterations)

          ## Your Task
          Evaluate the following issue. Respond with EXACTLY this format (one field per line):
          APPROVED: true|false
          COMPLEXITY: fast|standard|full
          TEMPLATE: fast|standard|full
          MAX_ITERATIONS: 5-30
          ESTIMATED_MINUTES: 15-120
          REASON: one-sentence explanation
          TRIAGE_EOF

          # Append issue details
          cat >> /tmp/triage-prompt.txt <<EOF

          ## Issue #${ISSUE_NUMBER}
          **Title**: ${TITLE}
          **Author**: ${AUTHOR}
          **Labels**: ${LABELS}
          **Body**:
          ${BODY}
          EOF

          # Call Claude via CLI for triage
          PROMPT_TEXT=$(cat /tmp/triage-prompt.txt)

          # Validate auth token exists
          if [[ -z "${CLAUDE_CODE_OAUTH_TOKEN:-}" ]]; then
            echo "WARNING: CLAUDE_CODE_OAUTH_TOKEN not set ‚Äî using defaults"
            RESPONSE="APPROVED: true
          COMPLEXITY: standard
          TEMPLATE: standard
          MAX_ITERATIONS: 20
          ESTIMATED_MINUTES: 90
          REASON: No auth token configured ‚Äî defaulting to approved"
          else
            # Install Claude Code for triage (lightweight, cached by npm)
            if ! command -v claude &>/dev/null; then
              npm install -g @anthropic-ai/claude-code 2>/dev/null || true
            fi

            RESPONSE=$(claude -p "$PROMPT_TEXT" --max-turns 1 --model claude-haiku-4-5-20251001 2>/dev/null || echo "")

            # Fail-safe: if Claude returns empty/garbage, reject (do not auto-approve)
            if [[ -z "$RESPONSE" ]]; then
              RESPONSE="APPROVED: false
          COMPLEXITY: standard
          TEMPLATE: standard
          MAX_ITERATIONS: 20
          ESTIMATED_MINUTES: 90
          REASON: Claude triage call failed or returned empty ‚Äî rejecting for safety"
            fi
          fi

          # Parse response
          APPROVED=$(echo "$RESPONSE" | grep -i "^APPROVED:" | head -1 | awk '{print $2}' | tr '[:upper:]' '[:lower:]')
          COMPLEXITY=$(echo "$RESPONSE" | grep -i "^COMPLEXITY:" | head -1 | awk '{print $2}' | tr '[:upper:]' '[:lower:]')
          REASON=$(echo "$RESPONSE" | grep -i "^REASON:" | head -1 | sed 's/^REASON: *//')

          # Fail-safe defaults: never auto-approve on parse failure
          APPROVED="${APPROVED:-false}"
          COMPLEXITY="${COMPLEXITY:-standard}"
          REASON="${REASON:-Could not parse triage response ‚Äî rejecting for safety}"

          echo "approved=$APPROVED" >> "$GITHUB_OUTPUT"
          echo "complexity=$COMPLEXITY" >> "$GITHUB_OUTPUT"
          echo "reason=$REASON" >> "$GITHUB_OUTPUT"

          echo "--- Triage Result ---"
          echo "Approved: $APPROVED"
          echo "Complexity: $COMPLEXITY"
          echo "Reason: $REASON"

      - name: Predictive risk assessment
        if: steps.skip.conclusion == 'skipped' && steps.triage.outputs.approved == 'true'
        id: risk
        run: |
          # Advisory only ‚Äî never blocks the pipeline
          set +e

          RISK_LEVEL="unknown"
          RISK_SCORE="0"

          if [[ -f "./scripts/sw-predictive.sh" ]]; then
            RISK_OUTPUT=$(bash ./scripts/sw-predictive.sh risk --issue "$ISSUE_NUMBER" --json 2>/dev/null || echo "{}")
            RISK_LEVEL=$(echo "$RISK_OUTPUT" | jq -r '.risk_level // "unknown"' 2>/dev/null || echo "unknown")
            RISK_SCORE=$(echo "$RISK_OUTPUT" | jq -r '.risk_score // "0"' 2>/dev/null || echo "0")

            echo "Risk assessment: level=$RISK_LEVEL score=$RISK_SCORE"
          else
            echo "Predictive script not found ‚Äî skipping risk assessment"
          fi

          echo "risk_level=$RISK_LEVEL" >> "$GITHUB_OUTPUT"
          echo "risk_score=$RISK_SCORE" >> "$GITHUB_OUTPUT"

      - name: Map strategy from triage
        if: steps.skip.conclusion == 'skipped' && steps.triage.outputs.approved == 'true'
        id: strategy
        run: |
          COMPLEXITY="${{ steps.triage.outputs.complexity }}"

          # Strategy mapping ‚Äî deterministic, not AI-dependent
          # Default to autonomous template for compound quality (adversarial review,
          # negative testing, e2e validation, DoD audit)
          case "$COMPLEXITY" in
            fast)
              TEMPLATE="fast"
              MAX_ITERATIONS=10
              ESTIMATED_MINUTES=45
              ;;
            full)
              TEMPLATE="autonomous"
              MAX_ITERATIONS=30
              ESTIMATED_MINUTES=120
              ;;
            *)
              TEMPLATE="autonomous"
              MAX_ITERATIONS=20
              ESTIMATED_MINUTES=90
              ;;
          esac

          # Bump strategy if predictive risk is high
          RISK_LEVEL="${{ steps.risk.outputs.risk_level }}"
          if [[ "$RISK_LEVEL" == "high" || "$RISK_LEVEL" == "critical" ]]; then
            echo "High risk detected ‚Äî escalating strategy"
            TEMPLATE="autonomous"
            MAX_ITERATIONS=$((MAX_ITERATIONS + 5))
          fi

          # Allow workflow_dispatch overrides
          INPUT_TEMPLATE="${{ github.event.inputs.template }}"
          if [[ -n "$INPUT_TEMPLATE" && "$INPUT_TEMPLATE" != "autonomous" ]]; then
            TEMPLATE="$INPUT_TEMPLATE"
          fi

          INPUT_ITERATIONS="${{ github.event.inputs.max_iterations }}"
          if [[ -n "$INPUT_ITERATIONS" && "$INPUT_ITERATIONS" != "0" ]]; then
            MAX_ITERATIONS="$INPUT_ITERATIONS"
          fi

          echo "template=$TEMPLATE" >> "$GITHUB_OUTPUT"
          echo "max_iterations=$MAX_ITERATIONS" >> "$GITHUB_OUTPUT"
          echo "estimated_minutes=$ESTIMATED_MINUTES" >> "$GITHUB_OUTPUT"

          echo "--- Strategy ---"
          echo "Template: $TEMPLATE"
          echo "Max Iterations: $MAX_ITERATIONS"
          echo "Estimated Minutes: $ESTIMATED_MINUTES"

      - name: Comment on rejected issue
        if: steps.triage.outputs.approved == 'false'
        run: |
          REASON="${{ steps.triage.outputs.reason }}"
          gh issue comment "$ISSUE_NUMBER" --body "$(cat <<EOF
          ‚öì **Shipwright Triage ‚Äî Issue Declined**

          This issue was reviewed by the automated triage system and does not appear to align with Shipwright's project goals.

          **Reason**: $REASON

          If you believe this is incorrect, a maintainer can override by:
          1. Running the workflow manually with "Skip triage" enabled
          2. Adding context to the issue and re-applying the \`shipwright\` label

          For questions or support, please use [Discussions](../../discussions) instead.
          EOF
          )"

      - name: Remove shipwright label from rejected issue
        if: steps.triage.outputs.approved == 'false'
        run: |
          gh issue edit "$ISSUE_NUMBER" --remove-label "shipwright" || true

  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  # Stage 2: Pipeline ‚Äî autonomous agent processes the approved issue
  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  pipeline:
    needs: triage
    if: needs.triage.outputs.approved == 'true'
    runs-on: ubuntu-latest
    # Generous timeout ‚Äî watchdog handles stuck detection via heartbeat signals
    timeout-minutes: 180

    env:
      ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number }}
      TEMPLATE: ${{ needs.triage.outputs.template || github.event.inputs.template || 'autonomous' }}
      MAX_ITERATIONS: ${{ needs.triage.outputs.max_iterations || '20' }}
      COMPLETED_STAGES: ${{ github.event.inputs.completed_stages || '' }}
      CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      NO_COLOR: "1"

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure git
        run: |
          git config user.name "shipwright[bot]"
          git config user.email "shipwright[bot]@users.noreply.github.com"

      - name: Restore persistent state
        run: |
          mkdir -p ~/.shipwright/memory
          if git fetch origin shipwright-data 2>/dev/null; then
            echo "Restoring state from shipwright-data branch..."
            for file in events.jsonl costs.json budget.json; do
              git show "origin/shipwright-data:${file}" > ~/.shipwright/"${file}" 2>/dev/null || true
            done
            for file in $(git ls-tree -r --name-only origin/shipwright-data -- memory/ 2>/dev/null); do
              mkdir -p ~/.shipwright/"$(dirname "$file")"
              git show "origin/shipwright-data:${file}" > ~/.shipwright/"${file}" 2>/dev/null || true
            done
            echo "State restored successfully"
          else
            echo "No shipwright-data branch found ‚Äî starting fresh"
          fi

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y tmux jq

      - name: Install Claude Code
        run: |
          npm install -g @anthropic-ai/claude-code

      - name: Install Shipwright
        run: |
          npm link

      - name: Pre-flight auth check
        run: |
          echo "Verifying Claude Code authentication..."
          if claude -p "Reply with exactly: AUTH_OK" --max-turns 1 2>/tmp/auth-check-err.log | grep -q "AUTH_OK"; then
            echo "Claude Code authentication verified"
          else
            echo "::error::Claude Code authentication failed ‚Äî check CLAUDE_CODE_OAUTH_TOKEN secret"
            echo "--- stderr ---"
            cat /tmp/auth-check-err.log 2>/dev/null || true
            echo "--- end ---"
            # Post failure comment on issue
            gh issue comment "$ISSUE_NUMBER" --body "$(cat <<'AUTHEOF'
          ## Pipeline Auth Failure

          Claude Code failed to authenticate. Check that `CLAUDE_CODE_OAUTH_TOKEN` is set and valid in repository secrets.

          Run `claude setup-token` locally to generate a fresh token.
          AUTHEOF
            )" 2>/dev/null || true
            exit 1
          fi

      - name: Check for partial work branch
        run: |
          BRANCH="shipwright/issue-${ISSUE_NUMBER}"
          if git ls-remote --heads origin "$BRANCH" 2>/dev/null | grep -q "$BRANCH"; then
            echo "Found partial work branch: $BRANCH"
            git fetch origin "$BRANCH" 2>/dev/null || true

            # Check if branch is polluted with API error artifacts
            LAST_MSG=$(git log -1 --format='%s' "origin/$BRANCH" 2>/dev/null || echo "")
            BRANCH_CONTENT=$(git log -5 --format='%s' "origin/$BRANCH" 2>/dev/null || echo "")
            if echo "$BRANCH_CONTENT" | grep -qiE 'Invalid API key|authentication_error|API key expired'; then
              echo "WARNING: Partial work branch appears polluted with API errors ‚Äî deleting and starting fresh"
              git push origin --delete "$BRANCH" 2>/dev/null || true
            else
              echo "Merging partial work branch..."
              git merge "origin/$BRANCH" --no-edit 2>/dev/null || {
                echo "Merge conflict on partial branch ‚Äî starting fresh"
                git merge --abort 2>/dev/null || true
              }
            fi
          fi

      - name: Verify merged artifacts
        run: |
          echo "--- Recovered Artifacts ---"
          RECOVERED=0
          for f in plan.md dod.md context-bundle.md design.md; do
            FPATH=".claude/pipeline-artifacts/${f}"
            if [[ -f "$FPATH" && -s "$FPATH" ]]; then
              LINES=$(wc -l < "$FPATH")
              echo "  ‚úì ${f}: ${LINES} lines"
              RECOVERED=$((RECOVERED + 1))
            else
              echo "  ‚úó ${f}: not found"
            fi
          done
          echo "Recovered ${RECOVERED} artifact file(s) from partial work branch"

      - name: Check claim lock and pipeline start cap
        id: claim_check
        run: |
          CLAIMED=$(gh issue view "$ISSUE_NUMBER" --json labels \
            --jq '[.labels[].name | select(startswith("claimed:"))] | .[0] // ""' 2>/dev/null || echo "")
          if [ -n "$CLAIMED" ]; then
            echo "Issue #$ISSUE_NUMBER claimed by $CLAIMED ‚Äî CI yielding to local daemon"
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Pipeline start cap ‚Äî prevent runaway retry loops
          PIPELINE_STARTS=$(gh issue view "$ISSUE_NUMBER" --json comments \
            --jq '[.comments[].body | select(contains("Pipeline Starting"))] | length' 2>/dev/null || echo "0")
          if [ "${PIPELINE_STARTS:-0}" -ge 6 ]; then
            echo "Pipeline start cap reached ($PIPELINE_STARTS attempts) for issue #$ISSUE_NUMBER"
            gh issue comment "$ISSUE_NUMBER" --body "$(cat <<CAPEOF
          :stop_sign: **Shipwright Pipeline ‚Äî Start Cap Reached**

          This issue has had **${PIPELINE_STARTS} pipeline attempts** ‚Äî exceeding the safety cap of 6.

          This usually means the issue cannot be solved autonomously and needs human review.
          Re-apply the \`shipwright\` label after clearing old pipeline comments to retry.
          CAPEOF
          )" 2>/dev/null || true
            gh issue edit "$ISSUE_NUMBER" --remove-label "shipwright" 2>/dev/null || true
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "skip=false" >> "$GITHUB_OUTPUT"
          echo "Pipeline starts so far: ${PIPELINE_STARTS:-0}/6"

      - name: Validate setup
        if: steps.claim_check.outputs.skip != 'true'
        run: |
          echo "--- Environment ---"
          echo "Issue: #$ISSUE_NUMBER"
          echo "Template: $TEMPLATE"
          echo "Max Iterations: $MAX_ITERATIONS"
          echo "Completed Stages: ${COMPLETED_STAGES:-none}"
          echo "Triage: ${{ needs.triage.outputs.reason }}"
          echo "Runner: $(uname -s) $(uname -m)"
          echo ""

          # Verify CLAUDE.md is present for build agent context
          if [[ -f ".claude/CLAUDE.md" ]]; then
            echo "CLAUDE.md: present ($(wc -l < .claude/CLAUDE.md) lines)"
          else
            echo "WARNING: .claude/CLAUDE.md not found ‚Äî build agent will lack project context"
          fi

          # Verify claude-code can find the project
          echo "Working directory: $(pwd)"
          echo "Git branch: $(git branch --show-current)"
          echo ""
          shipwright doctor || true

      - name: Comment on issue ‚Äî pipeline starting
        if: steps.claim_check.outputs.skip != 'true'
        run: |
          RESUME_NOTE=""
          if [[ -n "$COMPLETED_STAGES" ]]; then
            RESUME_NOTE="| Resume | Skipping: \`$COMPLETED_STAGES\` |"
          fi

          gh issue comment "$ISSUE_NUMBER" --body "$(cat <<EOF
          ‚öì **Shipwright Pipeline Starting**

          | Field | Value |
          |-------|-------|
          | Template | \`$TEMPLATE\` |
          | Complexity | \`${{ needs.triage.outputs.complexity }}\` |
          | Max Iterations | \`$MAX_ITERATIONS\` |
          | Triage | ${{ needs.triage.outputs.reason }} |
          | Runner | \`ubuntu-latest\` |
          | Risk Level | \`${{ needs.triage.outputs.risk_level || 'N/A' }}\` |
          | Workflow | [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |
          ${RESUME_NOTE}

          The autonomous pipeline is processing this issue. Updates will be posted as stages complete.
          <!-- SHIPWRIGHT-RUN-ID: ${{ github.run_id }} -->
          EOF
          )"

      - name: Notify dashboard ‚Äî pipeline starting
        if: steps.claim_check.outputs.skip != 'true'
        env:
          DASHBOARD_URL: ${{ secrets.DASHBOARD_URL }}
        run: |
          if [ -n "${DASHBOARD_URL:-}" ]; then
            curl -s --max-time 5 -X POST "${DASHBOARD_URL}/api/webhook/ci" \
              -H "Content-Type: application/json" \
              -d "{\"type\":\"ci.pipeline_started\",\"issue\":${ISSUE_NUMBER},\"run_id\":\"${{ github.run_id }}\",\"template\":\"${TEMPLATE}\"}" \
              2>/dev/null || true
          fi

      - name: Run Shipwright pipeline
        if: steps.claim_check.outputs.skip != 'true'
        id: pipeline
        run: |
          set +e          # Don't abort on failure ‚Äî we capture the exit code
          set -o pipefail # CRITICAL: preserve pipeline exit code through | tee

          PIPELINE_ARGS=(
            --issue "$ISSUE_NUMBER"
            --template "$TEMPLATE"
            --no-github-label
            --skip-gates
            --ci
          )

          # Pass max iterations if set
          if [[ "$MAX_ITERATIONS" != "0" && -n "$MAX_ITERATIONS" ]]; then
            PIPELINE_ARGS+=(--max-iterations "$MAX_ITERATIONS")
          fi

          # Pass completed stages for resume
          if [[ -n "$COMPLETED_STAGES" ]]; then
            PIPELINE_ARGS+=(--completed-stages "$COMPLETED_STAGES")
          fi

          # Heartbeat: post progress marker every 10 minutes so watchdog knows we're alive
          (while true; do
            sleep 600
            gh issue comment "$ISSUE_NUMBER" --body "<!-- SHIPWRIGHT-HEARTBEAT: $(date -u +%Y-%m-%dT%H:%M:%SZ):running -->" 2>/dev/null || true
          done) &
          HEARTBEAT_PID=$!

          shipwright pipeline start "${PIPELINE_ARGS[@]}" 2>&1 | tee /tmp/pipeline.log
          PIPELINE_EXIT=${PIPESTATUS[0]}  # Get exit code of pipeline, not tee

          # Stop heartbeat
          kill $HEARTBEAT_PID 2>/dev/null || true
          wait $HEARTBEAT_PID 2>/dev/null || true

          echo "exit_code=$PIPELINE_EXIT" >> "$GITHUB_OUTPUT"

          # Double-check: if state file says failed but exit code is 0, override
          if [[ "$PIPELINE_EXIT" -eq 0 && -f ".claude/pipeline-state.md" ]]; then
            STATE_STATUS=$(grep "^status:" ".claude/pipeline-state.md" 2>/dev/null | awk '{print $2}' || true)
            if [[ "$STATE_STATUS" == "failed" ]]; then
              echo "WARNING: Pipeline exited 0 but state says failed ‚Äî overriding to exit 1"
              echo "exit_code=1" >> "$GITHUB_OUTPUT"
              PIPELINE_EXIT=1
            fi
          fi

          exit $PIPELINE_EXIT

      - name: Pipeline vitals health check
        if: always() && steps.claim_check.outputs.skip != 'true' && steps.pipeline.outputs.exit_code == '0'
        id: vitals
        run: |
          set +e

          HEALTH_SCORE="N/A"
          HEALTH_VERDICT="unknown"

          if [[ -f "./scripts/sw-pipeline-vitals.sh" ]]; then
            VITALS_OUTPUT=$(bash ./scripts/sw-pipeline-vitals.sh --issue "$ISSUE_NUMBER" --json 2>/dev/null || echo "{}")
            HEALTH_SCORE=$(echo "$VITALS_OUTPUT" | jq -r '.health_score // "N/A"' 2>/dev/null || echo "N/A")
            HEALTH_VERDICT=$(echo "$VITALS_OUTPUT" | jq -r '.verdict // "unknown"' 2>/dev/null || echo "unknown")

            echo "Vitals: score=$HEALTH_SCORE verdict=$HEALTH_VERDICT"
          else
            echo "Vitals script not found ‚Äî skipping health check"
          fi

          echo "health_score=$HEALTH_SCORE" >> "$GITHUB_OUTPUT"
          echo "health_verdict=$HEALTH_VERDICT" >> "$GITHUB_OUTPUT"

      - name: Comment on issue ‚Äî pipeline result
        if: always() && steps.claim_check.outputs.skip != 'true'
        run: |
          EXIT_CODE="${{ steps.pipeline.outputs.exit_code }}"

          # Extract current/failed stage from pipeline state
          LAST_STAGE=""
          STATE_STATUS=""
          if [[ -f ".claude/pipeline-state.md" ]]; then
            LAST_STAGE=$(grep "current_stage:" ".claude/pipeline-state.md" 2>/dev/null | awk '{print $2}' || true)
            STATE_STATUS=$(grep "^status:" ".claude/pipeline-state.md" 2>/dev/null | awk '{print $2}' || true)
          fi

          # Gatekeeper: state file is the source of truth
          # If exit_code is empty/unreliable, use the state file
          if [[ -z "$EXIT_CODE" ]]; then
            if [[ "$STATE_STATUS" == "complete" ]]; then
              EXIT_CODE="0"
            else
              EXIT_CODE="1"
            fi
          fi

          # Double-check: never report success if state says failed
          if [[ "$EXIT_CODE" == "0" && "$STATE_STATUS" == "failed" ]]; then
            echo "GATEKEEPER: exit_code=0 but state=failed ‚Äî overriding to failure"
            EXIT_CODE="1"
          fi

          # Build stage timeline from SHIPWRIGHT-STAGE comments on the issue
          STAGE_TIMELINE=""
          COMPLETED_LIST=""
          STAGE_COMMENTS=$(gh issue view "$ISSUE_NUMBER" --json comments --jq '.comments[].body' 2>/dev/null | grep "SHIPWRIGHT-STAGE:" || true)
          if [[ -n "$STAGE_COMMENTS" ]]; then
            STAGE_TIMELINE="### Stage Timeline"$'\n'"| Stage | Status | Duration |"$'\n'"| ----- | ------ | -------- |"
            while IFS= read -r line; do
              # Format: <!-- SHIPWRIGHT-STAGE: stage:status:elapsed -->
              STAGE_DATA=$(echo "$line" | sed 's/.*SHIPWRIGHT-STAGE: //;s/ *-->.*//')
              STAGE_NAME=$(echo "$STAGE_DATA" | cut -d: -f1)
              STAGE_STATUS=$(echo "$STAGE_DATA" | cut -d: -f2)
              STAGE_ELAPSED=$(echo "$STAGE_DATA" | cut -d: -f3)
              if [[ "$STAGE_STATUS" == "complete" || "$STAGE_STATUS" == "completed" ]]; then
                ICON="‚úÖ"
                if [[ -n "$COMPLETED_LIST" ]]; then
                  COMPLETED_LIST="${COMPLETED_LIST}, ${STAGE_NAME}"
                else
                  COMPLETED_LIST="$STAGE_NAME"
                fi
              elif [[ "$STAGE_STATUS" == "failed" ]]; then
                ICON="‚ùå"
              elif [[ "$STAGE_STATUS" == "skipped" ]]; then
                ICON="‚è≠Ô∏è"
              else
                ICON="üîÑ"
              fi
              STAGE_TIMELINE="${STAGE_TIMELINE}"$'\n'"| ${STAGE_NAME} | ${ICON} | ${STAGE_ELAPSED:-‚Äî} |"
            done <<< "$STAGE_COMMENTS"
          fi

          # Read vitals output
          HEALTH_SCORE="${{ steps.vitals.outputs.health_score }}"
          HEALTH_VERDICT="${{ steps.vitals.outputs.health_verdict }}"
          HEALTH_SCORE="${HEALTH_SCORE:-N/A}"
          HEALTH_VERDICT="${HEALTH_VERDICT:-unknown}"

          if [[ "$EXIT_CODE" == "0" ]]; then
            # --- Success comment ---
            gh issue comment "$ISSUE_NUMBER" --body "$(cat <<EOF
          ‚úÖ **Pipeline Completed Successfully**

          ${STAGE_TIMELINE}

          | Health Score | ${HEALTH_SCORE} / 100 (${HEALTH_VERDICT}) |

          [View full run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          <!-- SHIPWRIGHT-RESULT: 0:${LAST_STAGE}:${{ github.run_id }} -->
          EOF
          )"
          else
            # --- Failure comment with structured analysis ---

            # Classify error type from log tail
            ERROR_TYPE="unknown"
            LOG_TAIL=""
            if [[ -f /tmp/pipeline.log ]]; then
              LOG_TAIL=$(tail -20 /tmp/pipeline.log 2>/dev/null || echo "")
              if echo "$LOG_TAIL" | grep -qi "test.*fail\|assertion.*fail\|FAIL\|jest\|pytest"; then
                ERROR_TYPE="test_failure"
              elif echo "$LOG_TAIL" | grep -qi "build.*error\|compile.*error\|syntax.*error\|tsc"; then
                ERROR_TYPE="build_error"
              elif echo "$LOG_TAIL" | grep -qi "timeout\|timed out\|exceeded.*time"; then
                ERROR_TYPE="timeout"
              elif echo "$LOG_TAIL" | grep -qi "rate.*limit\|quota\|429\|503\|ECONNREFUSED"; then
                ERROR_TYPE="infra"
              fi
            fi

            gh issue comment "$ISSUE_NUMBER" --body "$(cat <<EOF
          ‚ùå **Pipeline Failed** (exit code: $EXIT_CODE)

          ### Failure Analysis
          | Field | Value |
          | ----- | ----- |
          | Failed Stage | \`${LAST_STAGE:-unknown}\` |
          | Error Type | \`${ERROR_TYPE}\` |
          | Completed | ${COMPLETED_LIST:-none} |

          ${STAGE_TIMELINE}

          <details><summary>Last 20 lines of log</summary>

          \`\`\`
          ${LOG_TAIL}
          \`\`\`
          </details>

          [View full run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          <!-- SHIPWRIGHT-RESULT: ${EXIT_CODE}:${LAST_STAGE}:${{ github.run_id }} -->
          <!-- SHIPWRIGHT-FAILURE-ANALYSIS: stage=${LAST_STAGE:-unknown}:type=${ERROR_TYPE}:completed=${COMPLETED_LIST:-none} -->
          EOF
          )"
          fi

      - name: Push partial work on failure
        if: failure() && steps.claim_check.outputs.skip != 'true'
        run: |
          BRANCH="shipwright/issue-${ISSUE_NUMBER}"
          if ! git diff --quiet 2>/dev/null || ! git diff --cached --quiet 2>/dev/null; then
            git add -A 2>/dev/null || true
            git commit -m "WIP: partial pipeline progress for #${ISSUE_NUMBER}" --no-verify 2>/dev/null || true
          fi
          # Push branch (force to overwrite previous WIP)
          git push origin "HEAD:refs/heads/$BRANCH" --force 2>/dev/null || true
          echo "Partial work pushed to branch: $BRANCH"

      - name: Upload pipeline artifacts
        if: always() && steps.claim_check.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: pipeline-artifacts-${{ env.ISSUE_NUMBER }}
          path: |
            .claude/pipeline-state.md
            .claude/pipeline-artifacts/
          retention-days: 30
          if-no-files-found: ignore

      - name: Persist state to shipwright-data branch
        if: always() && steps.claim_check.outputs.skip != 'true'
        run: |
          SW_STATE_DIR=$(mktemp -d)
          cd "$SW_STATE_DIR"
          git init
          git remote add origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git"
          if git fetch origin shipwright-data 2>/dev/null; then
            git checkout -b shipwright-data origin/shipwright-data
          else
            git checkout --orphan shipwright-data
            echo "# Shipwright Persistent State" > README.md
          fi
          cp ~/.shipwright/events.jsonl . 2>/dev/null || true
          cp ~/.shipwright/costs.json . 2>/dev/null || true
          cp ~/.shipwright/budget.json . 2>/dev/null || true
          if [[ -d ~/.shipwright/memory ]]; then
            cp -r ~/.shipwright/memory . 2>/dev/null || true
          fi
          git config user.name "shipwright[bot]"
          git config user.email "shipwright[bot]@users.noreply.github.com"
          git add -A
          if git diff --cached --quiet 2>/dev/null; then
            echo "No state changes to persist"
          else
            git commit -m "chore: persist pipeline state [skip ci]"
            # Retry with jitter ‚Äî concurrent pipelines race on this branch
            PUSHED=false
            for ATTEMPT in 1 2 3 4 5; do
              if git push origin shipwright-data 2>/dev/null; then
                PUSHED=true
                break
              fi
              JITTER=$((RANDOM % 10 + 2))
              echo "Push attempt $ATTEMPT failed ‚Äî retrying in ${JITTER}s..."
              sleep "$JITTER"
              # Re-fetch, rebase, and retry
              git fetch origin shipwright-data 2>/dev/null || true
              git rebase origin/shipwright-data 2>/dev/null || {
                echo "Rebase conflict ‚Äî force pushing"
                git rebase --abort 2>/dev/null || true
                git push origin shipwright-data --force 2>/dev/null && PUSHED=true && break
              }
            done
            if [ "$PUSHED" = "true" ]; then
              echo "State persisted to shipwright-data branch"
            else
              echo "WARNING: Failed to persist state after 5 attempts ‚Äî non-fatal, continuing"
            fi
          fi

      - name: Notify dashboard ‚Äî pipeline result
        if: always() && steps.claim_check.outputs.skip != 'true'
        env:
          DASHBOARD_URL: ${{ secrets.DASHBOARD_URL }}
        run: |
          if [ -n "${DASHBOARD_URL:-}" ]; then
            EXIT_CODE="${{ steps.pipeline.outputs.exit_code }}"
            RESULT="success"
            if [ "${EXIT_CODE:-1}" != "0" ]; then RESULT="failure"; fi
            curl -s --max-time 5 -X POST "${DASHBOARD_URL}/api/webhook/ci" \
              -H "Content-Type: application/json" \
              -d "{\"type\":\"ci.pipeline_completed\",\"issue\":${ISSUE_NUMBER},\"run_id\":\"${{ github.run_id }}\",\"result\":\"${RESULT}\",\"template\":\"${TEMPLATE}\"}" \
              2>/dev/null || true
          fi

      # Gatekeeper: ensure job fails if pipeline failed (triggers auto-retry)
      - name: Propagate pipeline exit code
        if: always() && steps.claim_check.outputs.skip != 'true'
        run: |
          EXIT_CODE="${{ steps.pipeline.outputs.exit_code }}"
          if [[ -n "$EXIT_CODE" && "$EXIT_CODE" != "0" ]]; then
            echo "Pipeline failed with exit code $EXIT_CODE ‚Äî failing job to trigger auto-retry"
            exit 1
          fi
          # Final check: state file says failed?
          if [[ -f ".claude/pipeline-state.md" ]]; then
            STATUS=$(grep "^status:" ".claude/pipeline-state.md" 2>/dev/null | awk '{print $2}' || true)
            if [[ "$STATUS" == "failed" ]]; then
              echo "GATEKEEPER: state file says failed ‚Äî failing job"
              exit 1
            fi
          fi
