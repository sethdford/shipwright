name: Shipwright Pipeline

# Autonomous agents process labeled issues ‚Äî Shipwright building itself
on:
  issues:
    types: [labeled]
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Issue number to process"
        required: true
        type: number
      template:
        description: "Pipeline template (fast, standard, full, autonomous)"
        required: false
        default: "autonomous"
        type: choice
        options:
          - fast
          - standard
          - full
          - autonomous
          - cost-aware
      skip_triage:
        description: "Skip issue triage (maintainer override)"
        required: false
        default: false
        type: boolean
      max_iterations:
        description: "Max build loop iterations (0 = auto from triage)"
        required: false
        default: "0"
        type: string
      completed_stages:
        description: "Comma-separated stages to skip (for CI resume)"
        required: false
        default: ""
        type: string

# Only one pipeline per issue at a time
concurrency:
  group: shipwright-issue-${{ github.event.inputs.issue_number || github.event.issue.number }}
  cancel-in-progress: false

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  # Stage 1: Triage ‚Äî vet the issue and determine delivery strategy
  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  triage:
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event.action == 'labeled' && github.event.label.name == 'shipwright')
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      approved: ${{ steps.skip.outputs.approved || steps.triage.outputs.approved }}
      reason: ${{ steps.skip.outputs.reason || steps.triage.outputs.reason }}
      complexity: ${{ steps.skip.outputs.complexity || steps.triage.outputs.complexity }}
      template: ${{ steps.skip.outputs.template || steps.strategy.outputs.template }}
      max_iterations: ${{ steps.skip.outputs.max_iterations || steps.strategy.outputs.max_iterations }}
      estimated_minutes: ${{ steps.skip.outputs.estimated_minutes || steps.strategy.outputs.estimated_minutes }}

    env:
      ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number }}
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    steps:
      - uses: actions/checkout@v4

      - name: Skip triage (maintainer override)
        if: github.event.inputs.skip_triage == 'true'
        id: skip
        run: |
          echo "approved=true" >> "$GITHUB_OUTPUT"
          echo "reason=Maintainer override ‚Äî triage skipped" >> "$GITHUB_OUTPUT"
          echo "complexity=standard" >> "$GITHUB_OUTPUT"
          echo "template=standard" >> "$GITHUB_OUTPUT"
          echo "max_iterations=20" >> "$GITHUB_OUTPUT"
          echo "estimated_minutes=90" >> "$GITHUB_OUTPUT"

      - name: Fetch issue details
        if: steps.skip.conclusion == 'skipped'
        id: issue
        run: |
          ISSUE_JSON=$(gh issue view "$ISSUE_NUMBER" --json title,body,labels,author)
          TITLE=$(echo "$ISSUE_JSON" | jq -r '.title')
          BODY=$(echo "$ISSUE_JSON" | jq -r '.body // ""' | head -200)
          LABELS=$(echo "$ISSUE_JSON" | jq -r '[.labels[].name] | join(", ")')
          AUTHOR=$(echo "$ISSUE_JSON" | jq -r '.author.login')

          echo "title=$TITLE" >> "$GITHUB_OUTPUT"
          echo "author=$AUTHOR" >> "$GITHUB_OUTPUT"
          echo "labels=$LABELS" >> "$GITHUB_OUTPUT"

          # Save body to file (too long for env var)
          echo "$BODY" > /tmp/issue-body.txt

      - name: Vet issue alignment and determine strategy
        if: steps.skip.conclusion == 'skipped'
        id: triage
        run: |
          TITLE="${{ steps.issue.outputs.title }}"
          LABELS="${{ steps.issue.outputs.labels }}"
          AUTHOR="${{ steps.issue.outputs.author }}"
          BODY=$(cat /tmp/issue-body.txt 2>/dev/null || echo "")

          # Build triage prompt with strategy engine
          cat > /tmp/triage-prompt.txt <<'TRIAGE_EOF'
          You are the triage gate for the Shipwright open-source project.

          ## Shipwright Mission
          Shipwright orchestrates autonomous Claude Code agent teams. It provides:
          - Delivery pipelines (issue -> plan -> build -> test -> review -> PR)
          - Daemon-driven issue processing with auto-scaling
          - Fleet management across multiple repos
          - Agent heartbeats, checkpoints, and fault tolerance
          - Multi-machine distributed workers
          - Real-time web dashboard with agent presence
          - Cost intelligence and budget enforcement
          - Persistent memory and failure pattern learning
          - tmux-based team sessions with templates

          ## Alignment Criteria
          An issue ALIGNS if it:
          1. Improves Shipwright's core functionality (pipelines, daemons, fleet, dashboard)
          2. Fixes bugs or improves reliability/resilience
          3. Improves developer experience (CLI, docs, templates, setup)
          4. Adds cross-platform support (Linux, macOS, WSL)
          5. Improves test coverage or CI/CD
          6. Enhances cost efficiency, metrics, or observability
          7. Improves security or error handling

          An issue DOES NOT ALIGN if it:
          1. Requests features unrelated to agent orchestration
          2. Is spam, low-effort, or unclear
          3. Requests integration with unrelated tools (unless clearly valuable)
          4. Would introduce unnecessary complexity or scope creep
          5. Duplicates existing functionality
          6. Is a support question (should be a Discussion, not Issue)

          ## Complexity and Strategy
          Evaluate the issue and recommend a delivery strategy:
          - fast: trivial fix, typo, config change (< 30 min, ~5 iterations)
          - standard: feature or bugfix touching 2-5 files (< 2 hours, ~15 iterations)
          - full: significant feature or refactor (> 2 hours, multiple subsystems, ~25 iterations)

          ## Your Task
          Evaluate the following issue. Respond with EXACTLY this format (one field per line):
          APPROVED: true|false
          COMPLEXITY: fast|standard|full
          TEMPLATE: fast|standard|full
          MAX_ITERATIONS: 5-30
          ESTIMATED_MINUTES: 15-120
          REASON: one-sentence explanation
          TRIAGE_EOF

          # Append issue details
          cat >> /tmp/triage-prompt.txt <<EOF

          ## Issue #${ISSUE_NUMBER}
          **Title**: ${TITLE}
          **Author**: ${AUTHOR}
          **Labels**: ${LABELS}
          **Body**:
          ${BODY}
          EOF

          # Call Anthropic API directly for triage (no CLI install needed)
          PROMPT_TEXT=$(cat /tmp/triage-prompt.txt)
          RESPONSE=$(curl -s --max-time 30 \
            -H "x-api-key: ${ANTHROPIC_API_KEY}" \
            -H "anthropic-version: 2023-06-01" \
            -H "content-type: application/json" \
            -d "$(jq -n --arg prompt "$PROMPT_TEXT" '{
              model: "claude-haiku-4-5-20251001",
              max_tokens: 512,
              messages: [{role: "user", content: $prompt}]
            }')" \
            https://api.anthropic.com/v1/messages 2>/dev/null | \
            jq -r '.content[0].text // empty' 2>/dev/null || echo "APPROVED: true
          COMPLEXITY: standard
          TEMPLATE: standard
          MAX_ITERATIONS: 20
          ESTIMATED_MINUTES: 90
          REASON: Triage API unavailable ‚Äî defaulting to approved")

          # Parse response
          APPROVED=$(echo "$RESPONSE" | grep -i "^APPROVED:" | head -1 | awk '{print $2}' | tr '[:upper:]' '[:lower:]')
          COMPLEXITY=$(echo "$RESPONSE" | grep -i "^COMPLEXITY:" | head -1 | awk '{print $2}' | tr '[:upper:]' '[:lower:]')
          REASON=$(echo "$RESPONSE" | grep -i "^REASON:" | head -1 | sed 's/^REASON: *//')

          # Defaults if parsing fails
          APPROVED="${APPROVED:-true}"
          COMPLEXITY="${COMPLEXITY:-standard}"
          REASON="${REASON:-Could not parse triage response}"

          echo "approved=$APPROVED" >> "$GITHUB_OUTPUT"
          echo "complexity=$COMPLEXITY" >> "$GITHUB_OUTPUT"
          echo "reason=$REASON" >> "$GITHUB_OUTPUT"

          echo "--- Triage Result ---"
          echo "Approved: $APPROVED"
          echo "Complexity: $COMPLEXITY"
          echo "Reason: $REASON"

      - name: Map strategy from triage
        if: steps.skip.conclusion == 'skipped' && steps.triage.outputs.approved == 'true'
        id: strategy
        run: |
          COMPLEXITY="${{ steps.triage.outputs.complexity }}"

          # Strategy mapping ‚Äî deterministic, not AI-dependent
          case "$COMPLEXITY" in
            fast)
              TEMPLATE="fast"
              MAX_ITERATIONS=10
              ESTIMATED_MINUTES=45
              ;;
            full)
              TEMPLATE="full"
              MAX_ITERATIONS=30
              ESTIMATED_MINUTES=120
              ;;
            *)
              TEMPLATE="standard"
              MAX_ITERATIONS=20
              ESTIMATED_MINUTES=90
              ;;
          esac

          # Allow workflow_dispatch overrides
          INPUT_TEMPLATE="${{ github.event.inputs.template }}"
          if [[ -n "$INPUT_TEMPLATE" && "$INPUT_TEMPLATE" != "autonomous" ]]; then
            TEMPLATE="$INPUT_TEMPLATE"
          fi

          INPUT_ITERATIONS="${{ github.event.inputs.max_iterations }}"
          if [[ -n "$INPUT_ITERATIONS" && "$INPUT_ITERATIONS" != "0" ]]; then
            MAX_ITERATIONS="$INPUT_ITERATIONS"
          fi

          echo "template=$TEMPLATE" >> "$GITHUB_OUTPUT"
          echo "max_iterations=$MAX_ITERATIONS" >> "$GITHUB_OUTPUT"
          echo "estimated_minutes=$ESTIMATED_MINUTES" >> "$GITHUB_OUTPUT"

          echo "--- Strategy ---"
          echo "Template: $TEMPLATE"
          echo "Max Iterations: $MAX_ITERATIONS"
          echo "Estimated Minutes: $ESTIMATED_MINUTES"

      - name: Comment on rejected issue
        if: steps.triage.outputs.approved == 'false'
        run: |
          REASON="${{ steps.triage.outputs.reason }}"
          gh issue comment "$ISSUE_NUMBER" --body "$(cat <<EOF
          ‚öì **Shipwright Triage ‚Äî Issue Declined**

          This issue was reviewed by the automated triage system and does not appear to align with Shipwright's project goals.

          **Reason**: $REASON

          If you believe this is incorrect, a maintainer can override by:
          1. Running the workflow manually with "Skip triage" enabled
          2. Adding context to the issue and re-applying the \`shipwright\` label

          For questions or support, please use [Discussions](../../discussions) instead.
          EOF
          )"

      - name: Remove shipwright label from rejected issue
        if: steps.triage.outputs.approved == 'false'
        run: |
          gh issue edit "$ISSUE_NUMBER" --remove-label "shipwright" || true

  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  # Stage 2: Pipeline ‚Äî autonomous agent processes the approved issue
  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  pipeline:
    needs: triage
    if: needs.triage.outputs.approved == 'true'
    runs-on: ubuntu-latest
    # Dynamic timeout: estimated + 30 min buffer, capped at 180 (watchdog handles stuck detection)
    timeout-minutes: ${{ fromJSON(needs.triage.outputs.estimated_minutes || '90') + 30 > 180 && 180 || fromJSON(needs.triage.outputs.estimated_minutes || '90') + 30 }}

    env:
      ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number }}
      TEMPLATE: ${{ needs.triage.outputs.template || github.event.inputs.template || 'autonomous' }}
      MAX_ITERATIONS: ${{ needs.triage.outputs.max_iterations || '20' }}
      COMPLETED_STAGES: ${{ github.event.inputs.completed_stages || '' }}
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      NO_COLOR: "1"

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure git
        run: |
          git config user.name "shipwright[bot]"
          git config user.email "shipwright[bot]@users.noreply.github.com"

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y tmux jq

      - name: Install Claude Code
        run: |
          npm install -g @anthropic-ai/claude-code

      - name: Install Shipwright
        run: |
          npm link

      - name: Check for partial work branch
        run: |
          BRANCH="shipwright/issue-${ISSUE_NUMBER}"
          if git ls-remote --heads origin "$BRANCH" 2>/dev/null | grep -q "$BRANCH"; then
            echo "Found partial work branch: $BRANCH ‚Äî merging into workspace"
            git fetch origin "$BRANCH" 2>/dev/null || true
            git merge "origin/$BRANCH" --no-edit 2>/dev/null || {
              echo "Merge conflict on partial branch ‚Äî starting fresh"
              git merge --abort 2>/dev/null || true
            }
          fi

      - name: Validate setup
        run: |
          echo "--- Environment ---"
          echo "Issue: #$ISSUE_NUMBER"
          echo "Template: $TEMPLATE"
          echo "Max Iterations: $MAX_ITERATIONS"
          echo "Completed Stages: ${COMPLETED_STAGES:-none}"
          echo "Triage: ${{ needs.triage.outputs.reason }}"
          echo "Runner: $(uname -s) $(uname -m)"
          echo ""
          shipwright doctor || true

      - name: Comment on issue ‚Äî pipeline starting
        run: |
          RESUME_NOTE=""
          if [[ -n "$COMPLETED_STAGES" ]]; then
            RESUME_NOTE="| Resume | Skipping: \`$COMPLETED_STAGES\` |"
          fi

          gh issue comment "$ISSUE_NUMBER" --body "$(cat <<EOF
          ‚öì **Shipwright Pipeline Starting**

          | Field | Value |
          |-------|-------|
          | Template | \`$TEMPLATE\` |
          | Complexity | \`${{ needs.triage.outputs.complexity }}\` |
          | Max Iterations | \`$MAX_ITERATIONS\` |
          | Triage | ${{ needs.triage.outputs.reason }} |
          | Runner | \`ubuntu-latest\` |
          | Workflow | [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |
          ${RESUME_NOTE}

          The autonomous pipeline is processing this issue. Updates will be posted as stages complete.
          <!-- SHIPWRIGHT-RUN-ID: ${{ github.run_id }} -->
          EOF
          )"

      - name: Run Shipwright pipeline
        id: pipeline
        run: |
          set +e
          PIPELINE_ARGS=(
            --issue "$ISSUE_NUMBER"
            --template "$TEMPLATE"
            --no-github-label
            --skip-gates
            --ci
          )

          # Pass max iterations if set
          if [[ "$MAX_ITERATIONS" != "0" && -n "$MAX_ITERATIONS" ]]; then
            PIPELINE_ARGS+=(--max-iterations "$MAX_ITERATIONS")
          fi

          # Pass completed stages for resume
          if [[ -n "$COMPLETED_STAGES" ]]; then
            PIPELINE_ARGS+=(--completed-stages "$COMPLETED_STAGES")
          fi

          # Heartbeat: post progress marker every 10 minutes so watchdog knows we're alive
          (while true; do
            sleep 600
            gh issue comment "$ISSUE_NUMBER" --body "<!-- SHIPWRIGHT-HEARTBEAT: $(date -u +%Y-%m-%dT%H:%M:%SZ):running -->" 2>/dev/null || true
          done) &
          HEARTBEAT_PID=$!

          shipwright pipeline start "${PIPELINE_ARGS[@]}" 2>&1 | tee /tmp/pipeline.log
          PIPELINE_EXIT=$?

          # Stop heartbeat
          kill $HEARTBEAT_PID 2>/dev/null || true
          wait $HEARTBEAT_PID 2>/dev/null || true

          echo "exit_code=$PIPELINE_EXIT" >> "$GITHUB_OUTPUT"
          exit $PIPELINE_EXIT

      - name: Comment on issue ‚Äî pipeline result
        if: always()
        run: |
          EXIT_CODE="${{ steps.pipeline.outputs.exit_code }}"

          # Extract current/failed stage from pipeline state
          LAST_STAGE=""
          if [[ -f ".claude/pipeline-state.md" ]]; then
            LAST_STAGE=$(grep "current_stage:" ".claude/pipeline-state.md" 2>/dev/null | awk '{print $2}' || true)
          fi

          # Build stage timeline from SHIPWRIGHT-STAGE comments on the issue
          STAGE_TIMELINE=""
          COMPLETED_LIST=""
          STAGE_COMMENTS=$(gh issue view "$ISSUE_NUMBER" --json comments --jq '.comments[].body' 2>/dev/null | grep "SHIPWRIGHT-STAGE:" || true)
          if [[ -n "$STAGE_COMMENTS" ]]; then
            STAGE_TIMELINE="### Stage Timeline"$'\n'"| Stage | Status | Duration |"$'\n'"| ----- | ------ | -------- |"
            while IFS= read -r line; do
              # Format: <!-- SHIPWRIGHT-STAGE: stage:status:elapsed -->
              STAGE_DATA=$(echo "$line" | sed 's/.*SHIPWRIGHT-STAGE: //;s/ *-->.*//')
              STAGE_NAME=$(echo "$STAGE_DATA" | cut -d: -f1)
              STAGE_STATUS=$(echo "$STAGE_DATA" | cut -d: -f2)
              STAGE_ELAPSED=$(echo "$STAGE_DATA" | cut -d: -f3)
              if [[ "$STAGE_STATUS" == "complete" || "$STAGE_STATUS" == "completed" ]]; then
                ICON="‚úÖ"
                if [[ -n "$COMPLETED_LIST" ]]; then
                  COMPLETED_LIST="${COMPLETED_LIST}, ${STAGE_NAME}"
                else
                  COMPLETED_LIST="$STAGE_NAME"
                fi
              elif [[ "$STAGE_STATUS" == "failed" ]]; then
                ICON="‚ùå"
              elif [[ "$STAGE_STATUS" == "skipped" ]]; then
                ICON="‚è≠Ô∏è"
              else
                ICON="üîÑ"
              fi
              STAGE_TIMELINE="${STAGE_TIMELINE}"$'\n'"| ${STAGE_NAME} | ${ICON} | ${STAGE_ELAPSED:-‚Äî} |"
            done <<< "$STAGE_COMMENTS"
          fi

          if [[ "$EXIT_CODE" == "0" ]]; then
            # --- Success comment ---
            gh issue comment "$ISSUE_NUMBER" --body "$(cat <<EOF
          ‚úÖ **Pipeline Completed Successfully**

          ${STAGE_TIMELINE}

          [View full run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          <!-- SHIPWRIGHT-RESULT: 0:${LAST_STAGE}:${{ github.run_id }} -->
          EOF
          )"
          else
            # --- Failure comment with structured analysis ---

            # Classify error type from log tail
            ERROR_TYPE="unknown"
            LOG_TAIL=""
            if [[ -f /tmp/pipeline.log ]]; then
              LOG_TAIL=$(tail -20 /tmp/pipeline.log 2>/dev/null || echo "")
              if echo "$LOG_TAIL" | grep -qi "test.*fail\|assertion.*fail\|FAIL\|jest\|pytest"; then
                ERROR_TYPE="test_failure"
              elif echo "$LOG_TAIL" | grep -qi "build.*error\|compile.*error\|syntax.*error\|tsc"; then
                ERROR_TYPE="build_error"
              elif echo "$LOG_TAIL" | grep -qi "timeout\|timed out\|exceeded.*time"; then
                ERROR_TYPE="timeout"
              elif echo "$LOG_TAIL" | grep -qi "rate.*limit\|quota\|429\|503\|ECONNREFUSED"; then
                ERROR_TYPE="infra"
              fi
            fi

            gh issue comment "$ISSUE_NUMBER" --body "$(cat <<EOF
          ‚ùå **Pipeline Failed** (exit code: $EXIT_CODE)

          ### Failure Analysis
          | Field | Value |
          | ----- | ----- |
          | Failed Stage | \`${LAST_STAGE:-unknown}\` |
          | Error Type | \`${ERROR_TYPE}\` |
          | Completed | ${COMPLETED_LIST:-none} |

          ${STAGE_TIMELINE}

          <details><summary>Last 20 lines of log</summary>

          \`\`\`
          ${LOG_TAIL}
          \`\`\`
          </details>

          [View full run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          <!-- SHIPWRIGHT-RESULT: ${EXIT_CODE}:${LAST_STAGE}:${{ github.run_id }} -->
          <!-- SHIPWRIGHT-FAILURE-ANALYSIS: stage=${LAST_STAGE:-unknown}:type=${ERROR_TYPE}:completed=${COMPLETED_LIST:-none} -->
          EOF
          )"
          fi

      - name: Push partial work on failure
        if: failure()
        run: |
          BRANCH="shipwright/issue-${ISSUE_NUMBER}"
          if ! git diff --quiet 2>/dev/null || ! git diff --cached --quiet 2>/dev/null; then
            git add -A 2>/dev/null || true
            git commit -m "WIP: partial pipeline progress for #${ISSUE_NUMBER}" --no-verify 2>/dev/null || true
          fi
          # Push branch (force to overwrite previous WIP)
          git push origin "HEAD:refs/heads/$BRANCH" --force 2>/dev/null || true
          echo "Partial work pushed to branch: $BRANCH"

      - name: Upload pipeline artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: pipeline-artifacts-${{ env.ISSUE_NUMBER }}
          path: |
            .claude/pipeline-state.md
            .claude/pipeline-artifacts/
          retention-days: 30
          if-no-files-found: ignore
